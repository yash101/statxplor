/**
 * Simulation engine, v2 (actually v2, v1 was generated by an LLM this is the good stuff)
 */

import type { Edge, Node } from "reactflow";
// WorkerRunMessage type is defined in simulation.worker.ts but not used here

export type SimProbabilities = {
  p: number;
  hits: number;
  next: SimNode[];
  label: string | null;
  id: string | null; // Corresponding to output handle id
}

export type SimNode = {
  id: string;
  hits: number;
  error_term?: number;
  probabilities: SimProbabilities[];
}

type WorkerDetails = {
  worker: Worker;
  finished: boolean;
}

export class SimulationEngineV2 {
  private workers: WorkerDetails[] = [];
  private nodeMap = new Map<string, Node>();
  private mainSimNode: SimNode | null = null;
  private finishedWorkers: number = 0;
  private currentResolve: Function | null = null;
  private currentReject: Function | null = null;

  public reset() {
    for (const w of this.workers) {
      w.worker.terminate();
    }
    this.workers = [];
    this.nodeMap.clear();
    this.mainSimNode = null;
    this.finishedWorkers = 0;
    this.currentResolve = null;
    this.currentReject = null;
  }

  // Try to create a module worker; if not supported (Safari versions), fall back to classic
  private createWorker(url: URL): Worker {
    try {
      // Prefer module workers for modern bundlers (Vite output supports this)
      return new Worker(url, { type: 'module' } as WorkerOptions);
    } catch (e) {
      console.warn('Module worker failed, falling back to classic worker', e);
      return new Worker(url);
    }
  }

  private workerSentMessage(message: MessageEvent<any>, workerIndex: number) {
    const messageTypeMap: Record<string, Function> = {
      'results': () => {
        const {
          graph
        } = message.data;

        this.accumulateResults(graph);
      },
      'done': () => {
        this.workers[workerIndex].finished = true;
        this.finishedWorkers += 1;
        if (this.finishedWorkers === this.workers.length) {
          // All workers are done
          if (this.currentResolve)
            this.currentResolve();
          this.currentResolve = null;
          this.currentReject = null;
        }
      },
    };

    console.log('Worker message', workerIndex, message);

    const messageType: string = message.data?.type || '';
    const handler = messageTypeMap[messageType];
    if (handler) {
      handler();
    }
  }

  private workerError(message: ErrorEvent, workerIndex: number) {
    console.error('Worker error', workerIndex, message);
    if (this.currentReject) {
      this.currentReject(new Error(`Worker ${workerIndex} error: ${message.message}`));
    }
    this.reset();
  }

  public async runSimulation({
    workers,
    rays = 10000,
    frontierSize = 1000,
    variable,
    vStart,
    vEnd,
    vStepCount,
    graph,
  }: {
    workers?: number;
    rays: number;
    frontierSize: number;
    variable?: string;
    vStart?: number;
    vEnd?: number;
    vStepCount?: number;
    graph: SimNode;
  }): Promise<void> {
    // Determine a safe number of workers across browsers (Safari may report 1 core)
    const hc = Math.max(1, Number(window.navigator.hardwareConcurrency) || 1);
    const reqWorkers = (typeof workers === 'number' && workers > 0) ? Math.floor(workers) : Math.max(1, hc - 1);
    workers = Math.max(1, reqWorkers);

    let raysPerWorker = Math.floor(rays / workers);
    if (raysPerWorker < 1) {
      workers = 1;
      raysPerWorker = rays;
    } else if (raysPerWorker * workers < rays) {
      raysPerWorker += 1; // round up
    }

    // Ensure previous workers are terminated
    this.reset();
    this.mainSimNode = graph;

    for (let i = 0; i < workers; i++) {
      console.log('Spawning worker', i, 'of', workers, '(hc =', hc, ', raysPerWorker =', raysPerWorker, ')');
      const w = this.createWorker(new URL('./simulation.worker.ts', import.meta.url));
      this.workers.push({ worker: w, finished: false });

      // TODO
      w.addEventListener('message', ev => { this.workerSentMessage(ev, i); });
      w.addEventListener('messageerror', ev => { console.error('Worker messageerror', i, ev); });
      w.addEventListener('error', error => { this.workerError(error, i); });
      w.postMessage({
        type: 'run',
        rays: raysPerWorker,
        frontierSize,
        variable,
        vStart,
        vEnd,
        vStepCount,
        graph,
      });
    }

    return new Promise((resolve, reject) => {
      this.currentResolve = resolve;
      this.currentReject = reject;
    });
  }

  public buildSimTree(nodes: Node[], edges: Edge[]): SimNode {
    const head: SimNode = {
      id: 'root',
      hits: 0,
      probabilities: [{
        id: null,
        p: 1,
        hits: 0,
        label: '___root___', // For debugging
        next: [],
      }],
    };

    // Build a map of nodeId to Node for quick lookup
    const nodeMap: Record<string, {
      node: Node,
      sim: SimNode,
    }> = {};
    for (const node of nodes) {
      nodeMap[node.id] = {
        node,
        sim: {
          id: node.id,
          hits: 0,
          error_term: node.data?.error_term || 0.0,
          probabilities: (node.data?.outputs || []).map((out: any) => ({
            p: out.probability,
            hits: 0,
            next: [],
            id: out.id,
            label: out.label,
          })),
        }
      };
    }

    // Connect nodes based on edges
    for (const edge of edges) {
      const sourceNode = edge.source;
      const sourceHandle = edge.sourceHandle;
      const targetNode = edge.target;

      // Sanity check, not sure how this would happen
      if (!sourceNode || !targetNode || !sourceHandle)
        continue;

      const sourceSimNode = nodeMap[sourceNode]?.sim;
      const fromSimNode = sourceSimNode?.probabilities.find(p => p.id === sourceHandle);
      const targetSimNode = nodeMap[targetNode]?.sim;

      if (!sourceSimNode || !fromSimNode || !targetSimNode) {
        console.warn('Missing node in simulation build', { sourceNode, sourceHandle, targetNode });
        continue;
      }

      // Stitch together the DAG by linking the source to target
      fromSimNode.next.push(targetSimNode);
    }

    // Determine root nodes (nodes with no incoming edges) and set them as children of head
    const targetNodeIds = new Set(edges.map(e => e.target));
    for (const nodeId in nodeMap) {
      if (!targetNodeIds.has(nodeId)) {
        head.probabilities[0].next.push(nodeMap[nodeId].sim);
      }
    }

    // So far so gooooood :)
    return head;
  }

  private accumulateResults(head: SimNode) {
    // If we don't have a mainSimNode yet, take this as the main
    if (!head) return;
    if (!this.mainSimNode) {
      this.mainSimNode = head;
      return;
    }

    // Helper: build an index of id -> SimNode for the current mainSimNode
    const buildIndex = (root: SimNode) => {
      const map = new Map<string, SimNode>();
      const q: SimNode[] = [root];
      const seen = new Set<SimNode>();
      while (q.length > 0) {
        const n = q.shift()!;
        if (seen.has(n)) continue;
        seen.add(n);
        map.set(n.id, n);
        for (const p of n.probabilities || []) {
          for (const nxt of p.next || []) {
            q.push(nxt);
          }
        }
      }
      return map;
    };

    const mainIndex = buildIndex(this.mainSimNode);

    // Traverse the incoming worker graph and merge into mainSimNode
    const queue: SimNode[] = [head];
    const visited = new Set<SimNode>();
    while (queue.length > 0) {
      const node = queue.shift()!;
      if (visited.has(node))
        continue;

      visited.add(node);

      const target = mainIndex.get(node.id);
      if (target) {
        // Sum node-level hits
        target.hits = (target.hits || 0) + (node.hits || 0);

        // Merge each probability entry
        for (let i = 0; i < (node.probabilities || []).length; i++) {
          const p = node.probabilities[i];

          // Try to find matching probability in the target
          let tp = target.probabilities.find(x => x.id === p.id && x.id != null);
          if (!tp && p.id == null && p.label != null) {
            tp = target.probabilities.find(x => x.label === p.label);
          }
          if (!tp) {
            // Fallback to positional match if counts align
            if (i < target.probabilities.length) {
              tp = target.probabilities[i];
            }
          }

          if (tp) {
            tp.hits = (tp.hits || 0) + (p.hits || 0);
          } else {
            // If there's no match, clone and append to target
            const clone: SimProbabilities = {
              p: p.p,
              hits: p.hits || 0,
              next: [],
              id: p.id,
              label: p.label,
            };
            target.probabilities.push(clone);
          }
        }
      } else {
        // Node missing in main graph -- attach it under the main root as a best-effort
        const cloned: SimNode = {
          id: node.id,
          hits: node.hits || 0,
          error_term: node.error_term,
          probabilities: (node.probabilities || []).map(p => ({
            p: p.p,
            hits: p.hits || 0,
            next: [],
            id: p.id,
            label: p.label,
          })),
        };
        this.mainSimNode.probabilities[0].next.push(cloned);
        mainIndex.set(cloned.id, cloned);
      }

      // enqueue children
      for (const p of node.probabilities || []) {
        for (const nxt of p.next || []) {
          queue.push(nxt);
        }
      }
    }

    console.log('Current mainSimNode after accumulation:', this.mainSimNode);
  }

  getResults(): SimNode | null {
    return this.mainSimNode;
  }
}
