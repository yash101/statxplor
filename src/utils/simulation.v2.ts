/**
 * Simulation engine, v2 (actually v2, v1 was generated by an LLM this is the good stuff)
 */

import type { Connection, Edge, Node } from "reactflow";
// import { CustomNodeProps } from "../components/CustomNode";

export type SimProbabilities = {
  p: number;
  hits: number;
  next: SimNode[];
  label: string | null;
  id: string | null; // Corresponding to output handle id
}

export type SimNode = {
  id: string;
  hits: number;
  error_term?: number;
  probabilities: SimProbabilities[];
}

export class SimulationEngineV2 {
  public buildSimTree(nodes: Node[], edges: Edge[]): SimNode {
    const head: SimNode = {
      id: 'root',
      hits: 0,
      probabilities: [{
        id: null,
        p: 1,
        hits: 0,
        label: '___root___', // For debugging
        next: [],
      }],
    };

    // Build a map of nodeId to Node for quick lookup
    const nodeMap: Record<string, {
      node: Node,
      sim: SimNode,
    }> = {};
    for (const node of nodes) {
      nodeMap[node.id] = {
        node,
        sim: {
          id: node.id,
          hits: 0,
          error_term: node.data?.error_term || 0.0,
          probabilities: (node.data?.outputs || []).map((out: any) => ({
            p: out.probability,
            hits: 0,
            next: [],
            id: out.id,
            label: out.label,
          })),
        }
      };
    }

    // Connect nodes based on edges
    for (const edge of edges) {
      const sourceNode = edge.source;
      const sourceHandle = edge.sourceHandle;
      const targetNode = edge.target;

      // Sanity check, not sure how this would happen
      if (!sourceNode || !targetNode || !sourceHandle)
        continue;

      const sourceSimNode = nodeMap[sourceNode]?.sim;
      const fromSimNode = sourceSimNode?.probabilities.find(p => p.id === sourceHandle);
      const targetSimNode = nodeMap[targetNode]?.sim;

      if (!sourceSimNode || !fromSimNode || !targetSimNode) {
        console.warn('Missing node in simulation build', { sourceNode, sourceHandle, targetNode });
        continue;
      }

      // Stitch together the DAG by linking the source to target
      fromSimNode.next.push(targetSimNode);
    }

    // Determine root nodes (nodes with no incoming edges) and set them as children of head
    const targetNodeIds = new Set(edges.map(e => e.target));
    for (const nodeId in nodeMap) {
      if (!targetNodeIds.has(nodeId)) {
        head.probabilities[0].next.push(nodeMap[nodeId].sim);
      }
    }

    // So far so gooooood :)
    return head;
  }

  private getResults(): any {
  }
}
